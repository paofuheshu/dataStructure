# 线性结构和非线性结构

## 数据结构包括：线性结构和非线性结构。

## 线性结构

线性结构作为最常用的数据结构，其特点是数据元素之间存在一对一的线性关系
线性结构有两种不同的存储结构，即顺序存储结构和链式存储结构。顺序存储的线性表称为顺序表，顺序表中的存储元素是连续的
链式存储的线性表称为链表，链表中的存储元素不一定是连续的，元素节点中存放数据元素以及相邻元素的地址信息
线性结构常见的有：数组、队列、链表和栈，后面我们会详细讲解.

## 非线性结构

非线性结构包括：二维数组，多维数组，广义表，树结构，图结构



# 数据结构和算法

## 稀疏数组和队列

### 稀疏sparsearray数组

先看一个实际的需求

![image-20211202193218745](C:\Users\25502\AppData\Roaming\Typora\typora-user-images\image-20211202193218745.png)

分析问题: 
因为该二维数组的很多值是默认值0, 因此记录了很多没有意义的数据.->稀疏数组。

稀疏数组

基本介绍

当一个数组中大部分元素为０，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。

稀疏数组的处理方法是:
记录数组一共有几行几列，有多少个不同的值
把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模

![image-20211202193259510](C:\Users\25502\AppData\Roaming\Typora\typora-user-images\image-20211202193259510.png)

应用实例
使用稀疏数组，来保留类似前面的二维数组(棋盘、地图等等)
把稀疏数组存盘，并且可以从新恢复原来的二维数组数
整体思路分析

![image-20211202193318926](C:\Users\25502\AppData\Roaming\Typora\typora-user-images\image-20211202193318926.png)	

二维数组转稀疏数组的思路：

1：遍历原始的二维数组，得到有效数据的个数sum

2：根据sum就可以创建稀疏数组sparseArray  int[sum + 1] [3]

3：将二维数据的有效数据存入到稀疏数组

稀疏数组转二维数组的思路：

1：先读取稀疏数组的第一行，根据第一行的数据，创原始的二维数组，比如上面的chessArr = int[11][11]

2：在读取稀疏数组侯霁航的数据，并赋给原始的二维数组即可

代码实现：

```java
package com.paofu.data_structure.day02;

/**
 * @author zhangqiang
 * @version 1.0
 * @date 2021/12/2 19:34
 * 稀疏数组
 */
public class SparseArray {

    public static void main(String[] args) {
        // 定义一个原始的二维数组(11 * 11的棋盘  1代表黑色棋子  2代表蓝色棋子 0代表无子)
        int[][] chessArray = new int[11][11];
        chessArray[1][2] = 1;
        chessArray[2][3] = 2;
        chessArray[4][3] = 2;
        // 遍历输出
        System.out.println("原始的二维数组为:");
        for (int[] row : chessArray) {
            for (int data : row) {
                System.out.printf("%d\t" ,data);
            }
            System.out.println();
        }

        // 将二维数据转为稀疏数组
        // 1: 先遍历二维数组 得到非0数据的个数
        int sum = 0;
        for (int[] row : chessArray) {
            for (int data : row) {
                if (data != 0) {
                    sum++;
                }
            }
        }
        // 2: 创建对应的稀疏数组
        int[][] sparseArr = new int[sum + 1][3];
        // 3: 给稀疏数组赋值
        sparseArr[0][0] = 11;
        sparseArr[0][1] = 11;
        sparseArr[0][2] = sum;
        // 4: 遍历二维数据，将非0的数组放入稀疏数组
        // 定义count 用于记录是稀疏数组的第几行
        int count = 1;
        for (int i = 0; i < 11; i++) {
            for (int j = 0; j < 11; j++) {
                if (chessArray[i][j] != 0) {
                    sparseArr[count][0] = i;
                    sparseArr[count][1] = j;
                    sparseArr[count][2] = chessArray[i][j];
                    count++;
                }
            }
        }

        // 遍历输出稀疏数组
        System.out.println("转换后的稀疏数组为:");
        for (int i = 0; i < sparseArr.length; i++) {
            System.out.printf("%d\t%d\t%d\t\n", sparseArr[i][0], sparseArr[i][1], sparseArr[i][2]);
        }

        // 将转换后的稀疏数组还原成二维数据
        int row = sparseArr[0][0];
        int column = sparseArr[0][1];
        int[][] chessArray1 = new int[row][column];

        for (int i = 1; i < sparseArr.length; i++) {
            chessArray1[sparseArr[i][0]][sparseArr[i][1]] = sparseArr[i][2];
        }

        // 遍历还原后的二维数组
        System.out.println("还原后的二维数组为:");
        for (int[] row1 : chessArray1) {
            for (int data : row1) {
                System.out.printf("%d\t" ,data);
            }
            System.out.println();
        }
    }
}
```

课后练习

要求：
在前面的基础上，将稀疏数组保存到磁盘上，比如 map.data
恢复原来的数组时，读取map.data 进行恢复



# 队列

## 队列介绍

## 队列是一个有序列表，可以用数组或是链表来实现。

遵循先入先出的原则。即：先存入队列的数据，要先取出。后存入的要后取出
示意图：(使用数组模拟队列示意图)

![image-20211202205116586](C:\Users\25502\AppData\Roaming\Typora\typora-user-images\image-20211202205116586.png)

## 数组模拟队列

队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如下图, 其中 maxSize 是该队列的最大容量。

因为队列的输出、输入是分别从前后端来处理，因此需要两个变量 front及 rear分别记录队列前后端的下标，front 会随着数据输出而改变，而 rear则是随着数据输入而改变

![image-20211202205116586](C:\Users\25502\AppData\Roaming\Typora\typora-user-images\image-20211202205116586.png)

当我们将数据存入队列时称为”addQueue”，addQueue 的处理需要有两个步骤：思路分析 
将尾指针往后移：rear+1 , 当front == rear 【空】
若尾指针 rear 小于队列的最大下标 maxSize-1，则将数据存入 rear所指的数组元素中，否则无法存入数据。 rear  == maxSize - 1[队列满]

rear 是队列最后[含]
front 是队列最前元素[不含]

```java
package com.paofu.data_structure.day02;

import java.util.Scanner;

/**
 * @author zhangqiang
 * @version 1.0
 * @date 2021/12/2 20:57
 * 用数组实现模拟队列
 * 此例存在的问题  使用一次就不能使用了，取数据并没有真正的从数组中删除，没有达到复用的效果，后续优化成一个环形队列(取模的方式)
 */
public class ArrayQueueDemo {

    public static void main(String[] args) {
        // 创建队列
        ArrayQueue arrayQueue = new ArrayQueue(3);
        char key = ' ';
        Scanner scanner = new Scanner(System.in);
        boolean loop = true;
        while (loop) {
            System.out.println("s(show): 显示队列");
            System.out.println("e(exit): 退出队列");
            System.out.println("a(add): 添加数据到队列");
            System.out.println("g(get): 从队列取出数据");
            System.out.println("h(head): 查看队列头的数据");
            key = scanner.next().charAt(0);
            switch (key) {
                case 's':
                    arrayQueue.showArr();
                    break;
                case 'a':
                    System.out.println("请输入一个数字");
                    int value = scanner.nextInt();
                    arrayQueue.addQueue(value);
                    break;
                case 'g':
                    try {
                        int queue = arrayQueue.getQueue();
                        System.out.println("取出的数据是：" + queue);
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                    break;
                case 'h':
                    try {
                        int queue = arrayQueue.headQueue();
                        System.out.println("队列的头数据是：" + queue);
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                    break;
                case 'e':
                    scanner.close();
                    loop = false;
                default:
                    break;
            }
        }
        System.out.println("程序退出");
    }

}

/**
 * 使用数组模拟编写一个ArrayDemo类
 */
class ArrayQueue {
    /**
     * 表示数组的最大容量
     */
    private int maxSize;
    /**
     * 队列头指针
     */
    private int front;
    /**
     * 队列尾指针
     */
    private int rear;
    /**
     * 存放数组的数组
     */
    private int[] arr;

    /**
     * 创建队列的构造器 rear 是队列最后[含] front 是队列最前元素[不含]
     * @param arrayMaxSize  数组最大存放数据量
     */
    public ArrayQueue(int arrayMaxSize) {
        maxSize = arrayMaxSize;
        arr = new int[maxSize];
        front = -1;
        rear = -1;
    }

    /**
     * 判断队列是否满了
     * @return  boolean
     */
    public boolean isFull() {
        return rear == maxSize - 1;
    }

    /**
     * 判断队列是否为空
     * @return  boolean
     */
    public boolean isEmpty() {
        return rear == front;
    }

    public void addQueue(int n) {
        // 判断队列是否满了
        if (isFull()) {
            System.out.println("队列已经满了，无法加入数据");
            return;
        }
        rear++;
        arr[rear] = n;
    }

    /**
     * 获取队列的数据 数据出队列
     * @return  int
     */
    public int getQueue() {
        // 判断队列是否为空
        if (isEmpty()) {
            // 抛出异常
            throw new RuntimeException("队列是空的，无法取出数据");
        }
        front++;
        return arr[front];
    }

    /**
     * 显示队列的所有数据
     */
    public void showArr() {
        if (isEmpty()) {
            System.out.println("队列是空的，没有数据");
            return;
        }
        for (int i : arr) {
            System.out.println(i);
        }
    }

    /**
     * 显示队列的头数据和尾数据
     * @return  int
     */
    public int headQueue() {
        if (isEmpty()) {
            throw new RuntimeException("队列是空的，没有头数据");
        }
        return arr[front+1];
    }
}

```

## 数组模拟环形队列

对前面的数组模拟队列的优化，充分利用数组。因此将数组看做是一个环形的。(通过取模的方式来实现即可)

分析说明：
	1.尾索引的下一个为头索引时表示队列满，即将队列容量空出一个作为约定,这个在做判断队列满的时候需要注意 (rear + 1) % maxSize == front 满] 

2. rear == front [空]

代码展示：

```
package com.paofu.data_structure.day02.array;

import java.util.Scanner;

/**
 * @author zhangqiang
 * @version 1.0
 * @date 2021/12/2 20:57
 * 用数组实现模拟队列
 * 此例存在的问题  使用一次就不能使用了，取数据并没有真正的从数组中删除，没有达到复用的效果，后续优化成一个环形队列(取模的方式)
 */
public class CircleArrayQueueDemo {

    public static void main(String[] args) {
        // 创建队列 此时最大有效数据为3  因为留出了一个空间做约定

        CircleArrayQueue arrayQueue = new CircleArrayQueue(4);
        char key = ' ';
        Scanner scanner = new Scanner(System.in);
        boolean loop = true;
        while (loop) {
            System.out.println("s(show): 显示队列");
            System.out.println("e(exit): 退出队列");
            System.out.println("a(add): 添加数据到队列");
            System.out.println("g(get): 从队列取出数据");
            System.out.println("h(head): 查看队列头的数据");
            key = scanner.next().charAt(0);
            switch (key) {
                case 's':
                    arrayQueue.showArr();
                    break;
                case 'a':
                    System.out.println("请输入一个数字");
                    int value = scanner.nextInt();
                    arrayQueue.addQueue(value);
                    break;
                case 'g':
                    try {
                        int queue = arrayQueue.getQueue();
                        System.out.println("取出的数据是：" + queue);
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                    break;
                case 'h':
                    try {
                        int queue = arrayQueue.headQueue();
                        System.out.println("队列的头数据是：" + queue);
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                    break;
                case 'e':
                    scanner.close();
                    loop = false;
                default:
                    break;
            }
        }
        System.out.println("程序退出");
    }

}

class CircleArrayQueue {

    /**
     * 表示数组的最大容量
     */
    private int maxSize;
    /**
     * 队列头指针
     */
    private int front;
    /**
     * 队列尾指针
     */
    private int rear;
    /**
     * 存放数组的数组
     */
    private int[] arr;

    public CircleArrayQueue(int arrayMaxSize) {
        maxSize = arrayMaxSize;
        arr = new int[maxSize];
        front = 0;
        rear = 0;
    }

    /**
     * 判断队列是否满了
     * @return  boolean
     */
    public boolean isFull() {
        return (rear + 1) % maxSize == front;
    }

    /**
     * 判断队列是否为空
     * @return  boolean
     */
    public boolean isEmpty() {
        return rear == front;
    }

    public void addQueue(int n) {
        // 判断队列是否满了
        if (isFull()) {
            System.out.println("队列已经满了，无法加入数据");
            return;
        }
        arr[rear] = n;
        rear = (rear + 1) % maxSize;
    }

    /**
     * 获取队列的数据 数据出队列
     * @return  int
     */
    public int getQueue() {
        // 判断队列是否为空
        if (isEmpty()) {
            // 抛出异常
            throw new RuntimeException("队列是空的，无法取出数据");
        }
        // 分析front是指向队列的第一个元素
        // 1.先把front对应的值保留到一个临时变量
        // 2.将front后移
        // 3.将临时变量返回
        int value = arr[front];
        front = (front + 1) % maxSize;
        return value;
    }

    /**
     * 显示队列的所有数据
     */
    public void showArr() {
        if (isEmpty()) {
            System.out.println("队列是空的，没有数据");
            return;
        }
        // 从front开始遍历

        for (int i = front; i < front + size(); i++) {
            System.out.printf("arr[%d]=%d\n", i % maxSize, arr[i % maxSize]);
        }
    }

    /**
     * 求出当前队列有效数据的个数
     * @return
     */
    public int size () {
        return (rear + maxSize - front) % maxSize;
    }

    /**
     * 显示队列的头数据和尾数据
     *
     * @return  int
     */
    public int headQueue() {
        if (isEmpty()) {
            throw new RuntimeException("队列是空的，没有头数据");
        }
        return arr[front];
    }

}
```

# 链表(Linked List)介绍

链表是有序的列表，但是它在内存中是存储如下

![image-20211206214510282](C:\Users\25502\AppData\Roaming\Typora\typora-user-images\image-20211206214510282.png)

小结:
1:链表是以节点的方式来存储,是链式存储
2:每个节点包含 data 域， next 域：指向下一个节点.
3:如图：发现链表的各个节点不一定是连续存储.
4:链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定

# 单链表介绍

## 单链表(带头结点) 逻辑结构示意图如下

![image-20211206214617350](C:\Users\25502\AppData\Roaming\Typora\typora-user-images\image-20211206214617350.png)

## 单链表的应用实例

使用带head头的单向链表实现 –水浒英雄排行榜管理
完成对英雄人物的增删改查操作， 注: 删除和修改,查找可以考虑学员独立完成，也可带学员完成
第一种方法在添加英雄时，直接添加到链表的尾部
第二种方式在添加英雄时，根据排名将英雄插入到指定位置(如果有这个排名，则添加失败，并给出提示)

代码展示：

```
package com.paofu.data_structure.day02.linkedList;

import lombok.Data;

/**
 * @author zhangqiang
 * @version 1.0
 * @date 2021/12/6 19:57
 * 单向列表
 */
public class SingleLinkedListDemo {

    public static void main(String[] args) {
        HeroNode node1 = new HeroNode(1, "宋江", "及时雨");
        HeroNode node2 = new HeroNode(2, "卢俊义", "玉麒麟");
        HeroNode node3 = new HeroNode(3, "吴用", "智多星");
        HeroNode node4 = new HeroNode(4, "林冲", "豹子头");
        HeroNode node5 = new HeroNode(2, "李逵", "黑旋风");
        // 创建单向链表
        SingleLinkedList singleLinkedList = new SingleLinkedList();
        singleLinkedList.addByOrder(node3);
        singleLinkedList.addByOrder(node2);
        singleLinkedList.addByOrder(node1);
        singleLinkedList.addByOrder(node4);
        // 修改2号
        singleLinkedList.update(node5);
        // 删除3号
        singleLinkedList.delete(node3);
        singleLinkedList.list();
        // 获取链表的有效个数
        int linkedListNum = SingleLinkedListUtil.getLinkedListNum(singleLinkedList.getHead());
        System.out.println("有效节点个数为：" + linkedListNum + "个");
        // 查找倒数第二个节点
        System.out.println(SingleLinkedListUtil.getLastIndexNode(singleLinkedList.getHead(), 1));
        // 翻转单链表
        SingleLinkedListUtil.reverseList(singleLinkedList.getHead());
        singleLinkedList.list();
        // 逆序打印(链表本身结构没有发生变化)
        SingleLinkedListUtil.showStackList(singleLinkedList.getHead());

    }
}

/**
 * 定义一个singleLinkedList管理
 */
class SingleLinkedList {
    /**
     * 先初始化一个头节点，不存放数据  头节点不能动
     */
    private HeroNode head = new HeroNode(0, "", "");

    public HeroNode getHead() {
        return head;
    }

    /**
     * 不考虑编号顺序时，找到最后一个节点指向本节点
     * 添加节点到单向列表
     * @param heroNode
     */
    public void add(HeroNode heroNode) {
        HeroNode temp = head;
        while (true) {
            if (temp.next == null) {
                break;
            }
            temp = temp.next;
        }
        // 当退出while时 temp指向最后一个节点
        temp.next = heroNode;
    }

    /**
     * 根据顺序添加
     * @param heroNode
     */
    public void addByOrder(HeroNode heroNode) {
        HeroNode temp = head;
        // 标识添加的编号是否存在
        boolean flag = false;
        while (true) {
            if (temp.next == null) {
                break;
            }
            if (temp.next.number > heroNode.number) {
                break;
            } else if (temp.next.number  == heroNode.number) {
                flag = true;
                break;
            }
            temp = temp.next;
        }

        if (flag) {
            System.out.println("编号已经存在，无法添加");
        } else {
            heroNode.next = temp.next;
            temp.next = heroNode;
        }
    }

    /**
     * 根据编号修改节点
     */
    public void update(HeroNode heroNode) {
        HeroNode temp = head.next;
        boolean flag = false;
        while (true) {
            if (temp.getNumber() == heroNode.getNumber()) {
                flag = true;
                break;
            }
            temp = temp.next;
        }
        if (flag) {
            temp.name = heroNode.name;
            temp.nickname = heroNode.nickname;
        } else {
            System.out.println("没有找到编号相同的节点，无法修改");
        }
    }

    /**
     * 根据编号删除节点
     */
    public void delete(HeroNode heroNode) {
        HeroNode temp = head.next;
        boolean flag = false;
        while (true) {
            if (temp.next.getNumber() == heroNode.getNumber()) {
                flag = true;
                break;
            }
            temp = temp.next;
        }
        if (flag) {
            temp.next = temp.next.next;
        } else {
            System.out.println("没有找到编号相同的节点，无法修改");
        }
    }

    /**
     * 显示遍历链表
     */
    public void list() {
        if (head.next == null) {
            System.out.println("链表为空");
            return;
        }
        HeroNode temp = head.next;
        while (true) {
            if (temp == null) {
                break;
            }
            System.out.println(temp);
            // 将temp后移
            temp = temp.next;
        }
    }

}

/**
 * 定义HeroNode节点对象
 */
@Data
class HeroNode {
    public int number;

    public String name;

    public String nickname;

    public HeroNode next;

    public HeroNode(int heroNumber, String heroName, String heroNickname) {
        this.number = heroNumber;
        this.name = heroName;
        this.nickname = heroNickname;
    }

    @Override
    public String toString() {
        return "HeroNode{" +
                "number=" + number +
                ", name='" + name + '\'' +
                ", nickname='" + nickname + '\'' +
                '}';
    }
}

```

## 单链表测试

1：求单链表中有效节点的个数
2：查找单链表中的倒数第k个结点 【新浪面试题】
3：单链表的反转【腾讯面试题，有点难度】
4：从尾到头打印单链表 【百度，要求方式1：反向遍历 。 方式2：Stack栈】
5：合并两个有序的单链表，合并之后的链表依然有序【课后练习.】

链表翻转示意图：

![image-20211207215911228](C:\Users\25502\AppData\Roaming\Typora\typora-user-images\image-20211207215911228.png)

代码示例：

```
package com.paofu.data_structure.day02.linkedList;

import java.util.Stack;

/**
 * @author zhangqiang
 * @version 1.0
 * @date 2021/12/7 19:19
 */
public class SingleLinkedListUtil {

    /**
     * 获取单链表的节点的个数(如果是带头节点的链表，不统计头节点)
     * @param heroNode
     * @return
     */
    public static int getLinkedListNum(HeroNode heroNode) {
        int num = 0;
        if (heroNode.next == null) {
            return 0;
        }
        HeroNode next = heroNode.next;
        while (next != null) {
            num++;
            next = next.next;
        }
        return num;
    }

    /**
     * 查找倒数第index个元素
      * @param heroNode
     * @param index
     * @return
     */
    public static HeroNode getLastIndexNode(HeroNode heroNode, int index) {
        if (heroNode.next == null) {
            return null;
        }
        // 得到链表的长度
        int length = getLinkedListNum(heroNode);
        // 遍历
        if (index <= 0 || index > length) {
            return null;
        }
        HeroNode node = heroNode.next;
        for (int i = 0; i < length - index; i++) {
            node = node.next;
        }
        return node;
    }

    /**
     * 将单链表翻转
     * @param heroNode
     */
    public static void reverseList(HeroNode heroNode) {
        if (heroNode.next == null || heroNode.next.next == null) {
            return;
        }
        HeroNode node = heroNode.next;
        HeroNode next = null;
        HeroNode reverseNode = new HeroNode(0,"", "");
        while (node != null) {
            next = node.next;
            node.next = reverseNode.next;
            reverseNode.next = node;
            node = next;
        }
        heroNode.next = reverseNode.next;
    }

    /**
     * 使用栈来进行逆序打印
     * @param heroNode
     */
    public static void showStackList(HeroNode heroNode) {
        if (heroNode.next == null) {
            return;
        }
        Stack<HeroNode> heroNodeStack = new Stack<>();
        HeroNode temp = heroNode.next;
        while (temp != null) {
            heroNodeStack.push(temp);
            temp = temp.next;
        }
        while (heroNodeStack.size() > 0) {
            System.out.println(heroNodeStack.pop());
        }
    }

    /**
     * 将两个有序的单向链表合并成一个
     * @param heroNode
     */
    public static void addOtherList(HeroNode heroNode) {
        // todo
    }
}
```

## 双向链表应用实例

使用带head头的双向链表实现 –水浒英雄排行榜
管理单向链表的缺点分析: 
单向链表，查找的方向只能是一个方向，而双向链表可以向前或者向后查找。
单向链表不能自我删除，需要靠辅助节点 ，而双向链表，则可以自我删除，所以前面我们单链表删除时节点，总是找到temp,temp是待删除节点的前一个节点。

代码示例：

```
package com.paofu.data_structure.day02.linkedList;

import lombok.Data;

/**
 * @author zhangqiang
 * @version 1.0
 * @date 2021/12/7 21:18
 * 双向链表模拟
 */
public class DoubleLinkedListDemo {

    public static void main(String[] args) {
        HeroNode2 node1 = new HeroNode2(1, "宋江", "及时雨");
        HeroNode2 node2 = new HeroNode2(2, "卢俊义", "玉麒麟");
        HeroNode2 node3 = new HeroNode2(3, "吴用", "智多星");
        HeroNode2 node4 = new HeroNode2(4, "林冲", "豹子头");
        HeroNode2 node5 = new HeroNode2(2, "李逵", "黑旋风");
        // 创建单向链表
        DoubleLikedList doubleLikedList = new DoubleLikedList();
        doubleLikedList.addByOrder(node3);
        doubleLikedList.addByOrder(node1);
        doubleLikedList.addByOrder(node4);
        doubleLikedList.addByOrder(node2);

        doubleLikedList.list();
        System.out.println("--------------------");
        doubleLikedList.update(node5);
        doubleLikedList.list();
        System.out.println("--------------------");
        doubleLikedList.delete(node3);
        doubleLikedList.list();
    }
}

class DoubleLikedList {

    /**
     * 先初始化一个头节点，不存放数据
     */
    private HeroNode2 head = new HeroNode2(0, "", "");

    public HeroNode2 getHead() {
        return head;
    }

    /**
     * 不考虑编号顺序时，找到最后一个节点指向本节点
     * 添加节点到单向列表
     * @param heroNode
     */
    public void add(HeroNode2 heroNode) {
        HeroNode2 temp = head;
        while (true) {
            if (temp.next == null) {
                break;
            }
            temp = temp.next;
        }
        // 当退出while时 temp指向最后一个节点
        temp.next = heroNode;
        heroNode.pre = temp;
    }

    /**
     * 根据顺序添加
     * @param heroNode
     */
    public void addByOrder(HeroNode2 heroNode) {
        HeroNode2 temp = head;
        // 标识添加的编号是否存在
        boolean flag = false;
        while (true) {
            if (temp.next == null) {
                break;
            }
            if (temp.next.number > heroNode.number) {
                break;
            } else if (temp.next.number  == heroNode.number) {
                flag = true;
                break;
            }
            temp = temp.next;
        }

        if (flag) {
            System.out.println("编号已经存在，无法添加");
        } else {
            heroNode.next = temp.next;
            heroNode.pre = temp;
            if (temp.next != null) {
                temp.next.pre = heroNode;
            }
            temp.next = heroNode;
        }
    }

    /**
     * 根据编号修改节点
     */
    public void update(HeroNode2 heroNode) {
        HeroNode2 temp = head.next;
        boolean flag = false;
        while (true) {
            if (temp.getNumber() == heroNode.getNumber()) {
                flag = true;
                break;
            }
            temp = temp.next;
        }
        if (flag) {
            temp.name = heroNode.name;
            temp.nickname = heroNode.nickname;
        } else {
            System.out.println("没有找到编号相同的节点，无法修改");
        }
    }

    /**
     * 根据编号删除节点
     */
    public void delete(HeroNode2 heroNode) {
        HeroNode2 temp = head.next;
        boolean flag = false;
        while (true) {
            if (temp.getNumber() == heroNode.getNumber()) {
                flag = true;
                break;
            }
            temp = temp.next;
        }
        if (flag) {
            temp.pre.next = temp.next;
            if (temp.next != null) {
                temp.next.pre = temp.pre;
            }
        } else {
            System.out.println("没有找到编号相同的节点，无法修改");
        }
    }

    /**
     * 显示遍历链表
     */
    public void list() {
        if (head.next == null) {
            System.out.println("链表为空");
            return;
        }
        HeroNode2 temp = head.next;
        while (true) {
            if (temp == null) {
                break;
            }
            System.out.println(temp);
            // 将temp后移
            temp = temp.next;
        }
    }

}

/**
 * 定义HeroNode节点对象
 */
@Data
class HeroNode2 {
    public int number;

    public String name;

    public String nickname;

    public HeroNode2 next;

    public HeroNode2 pre;

    public HeroNode2(int heroNumber, String heroName, String heroNickname) {
        this.number = heroNumber;
        this.name = heroName;
        this.nickname = heroNickname;
    }

    @Override
    public String toString() {
        return "HeroNode2{" +
                "number=" + number +
                ", name='" + name + '\'' +
                ", nickname='" + nickname + '\'' +
                '}';
    }
}
```

## 单向环形链表应用场景

Josephu(约瑟夫、约瑟夫环)  问题Josephu  问题为：设编号为1，2，… n的n个人围坐一圈，约定编号为k（1<=k<=n）的人从1开始报数，数到m 的那个人出列，它的下一位又从1开始报数，数到m的那个人又出列，依次类推，直到所有人出列为止，由此产生一个出队编号的序列。

提示：用一个不带头结点的循环链表来处理Josephu 问题：先构成一个有n个结点的单循环链表，然后由k结点起从1开始计数，计到m时，对应结点从链表中删除，然后再从被删除结点的下一个结点又从1开始计数，直到最后一个结点从链表中删除算法结束。

![1638972196161](D:\360MoveData\Users\25502\Desktop\数据结构\assets\1638972196161.png)

代码展示：

```java
package com.paofu.data_structure.day02.linkedList;

import lombok.Data;

/**
 * @author zhangqiang
 * @version 1.0
 * @date 2021/12/8 19:21
 */
public class CircleSingleLinkedListDemo {

    public static void main(String[] args) {
        // 测试构建和遍历
        CircleSingleLinkedList circleSingleLinkedList = new CircleSingleLinkedList();
        circleSingleLinkedList.addBoy(200);
        circleSingleLinkedList.list();
        circleSingleLinkedList.countBoy(10, 5, 10);
    }
}

/**
 * 创建环形单向列表
 */
class CircleSingleLinkedList {
    /**
     * 创建一个first节点，当前没有编号
     */
    private Boy first = null;

    /**
     * 添加小孩节点，形成环形链表
     * @param nums 共有几个节点
     */
    public void addBoy(int nums) {
        if (nums < 1) {
            System.out.println("nums的值不正确");
            return;
        }
        Boy curBoy = null;
        // 创建链表
        for (int i = 1; i <= nums; i++) {
            Boy boy = new Boy(i);
            // 如果是第一个小孩
            if (i == 1) {
                first = boy;
                first.setNext(first);
                curBoy = first;
            } else {
                curBoy.setNext(boy);
                boy.setNext(first);
                curBoy = boy;
            }

        }
    }

    /**
     * 遍历链表
     */
    public void list() {
        if (first == null) {
            System.out.println("当前链表为空");
            return;
        }
        Boy curBoy = first;
        while (true) {
            System.out.println("小孩的编号为：" + curBoy.getNumber());
            if (curBoy.getNext() == first) {
                break;
            }
            curBoy = curBoy.getNext();
        }
    }

    /**
     * 根据输入 计算出小孩出圈的顺序
     * @param startNum  第几个小孩开始数
     * @param countNum  数几个
     * @param nums  最初有多少小孩
     */
    public void countBoy(int startNum, int countNum, int nums) {
        if (first == null || startNum < 1 || startNum > nums) {
            System.out.println("参数输入有误，请重新输入");
            return;
        }
        // 将helper首先指向最后一个节点
        Boy helper = first;
        while (true) {
            if (helper.getNext() == first) {
                break;
            }
            helper = helper.getNext();
        }
        // 小孩报数前 先让first 和 helper 移动 startNum-1次
        for (int i = 0; i < startNum - 1; i++) {
            first = first.getNext();
            helper = helper.getNext();
        }
        // 小孩报数时，让first 和 helper移动countNum - 1次 然后出圈
        int count = 0;
        while (true) {
            if (helper == first) {
                break;
            }
            for (int i = 0; i < countNum - 1; i++) {
                first = first.getNext();
                helper = helper.getNext();
            }
            // first指向的就是要出圈的
            System.out.println("此次出圈的小孩的编号为：" + first.getNumber());
            count++;
            first = first.getNext();
            helper.setNext(first);
        }
        System.out.println("最后留在圈中的小孩的编号为：" + first.getNumber());
        System.out.println("总共出圈了：" + (count + 1) + "个小孩");
    }
}

/**
 * 创建boy类
 */
@Data
class Boy {
    private int number;

    private Boy next;

    public Boy(int number) {
        this.number = number;
    }
}
```

# 栈

## 栈的一个实际需求

请输入一个表达式

![1638972387511](D:\360MoveData\Users\25502\Desktop\数据结构\assets\1638972387511.png)

请问: 计算机底层是如何运算得到结果的？ 注意不是简单的把算式列出运算,因为我们看这个算式 7 * 2 * 2 - 5, 但是计算机怎么理解这个算式的(对计算机而言，它接收到的就是一个字符串)，我们讨论的是这个问题。-> 栈

## 栈的介绍

1:栈的英文为(stack)

2:栈是一个先入后出(FILO-First In Last Out)的有序列表。

3:栈(stack)是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。允许插入和删除的一端，为变化的一端，称为栈顶(Top)，另一端为固定的一端，称为栈底(Bottom)。

4:根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元素最先删除，最先放入的元素最后删除

5:出栈(pop)和入栈(push)的概念(如图所示)

![1638972463270](D:\360MoveData\Users\25502\Desktop\数据结构\assets\1638972463270.png)

![1638972468800](D:\360MoveData\Users\25502\Desktop\数据结构\assets\1638972468800.png)

## 栈的应用场景

1：子程序的调用：在跳往子程序前，会先将下个指令的地址存到堆栈中，直到子程序执行完后再将地址取出，以回到原来的程序中。 

2：处理递归调用：和子程序的调用类似，只是除了储存下一个指令的地址外，也将参数、区域变量等数据存入堆栈中。

3：表达式的转换[中缀表达式转后缀表达式]与求值(实际解决)。

4：二叉树的遍历。

5：图形的深度优先(depth一first)搜索法。

## 栈的快速入门

用数组模拟栈的使用，由于栈是一种有序列表，当然可以使用数组的结构来储存栈的数据内容，下面我们就用数组模拟栈的出栈，入栈等操作。

代码展示：

```
package com.paofu.data_structure.day02.stack;

import java.util.Scanner;

/**
 * @author zhangqiang
 * @version 1.0
 * @date 2021/12/8 20:43
 * 使用数组模拟栈
 */
public class ArrayStackDemo {

    public static void main(String[] args) {
        // 测试
        ArrayStack arrayStack = new ArrayStack(4);
        String key = "";
        boolean flag = true;
        Scanner scanner = new Scanner(System.in);
        while (flag) {
            System.out.println("show：显示栈");
            System.out.println("exit：退出程序");
            System.out.println("push：添加数据");
            System.out.println("pop：取出数据");
            System.out.println("请输入指令");
            key = scanner.next();
            switch (key) {
                case "show":
                    arrayStack.list();
                    break;
                case "push":
                    System.out.println("请输入一个数");
                    int value = scanner.nextInt();
                    arrayStack.push(value);
                    break;
                case "pop":
                    try {
                        int pop = arrayStack.pop();
                        System.out.println("出栈数据为：" + pop);
                    } catch (Exception e) {
                        System.out.println(e.getMessage());
                    }
                    break;
                case "exit":
                    scanner.close();
                    flag = false;
                    break;
                default:
                    break;
            }
        }
        System.out.println("程序退出了");
    }
}

/**
 * 定义一个栈结构
 */
class ArrayStack {

    /**
     * 栈的大小
     */
    private int maxSize;

    /**
     * 数组模拟栈，数据存放在数组中
     */
    private int[] stack;

    /**
     * 栈顶  初始化为-1
     */
    private int top = -1;

    public ArrayStack(int maxSize) {
        this.maxSize = maxSize;
        stack = new int[this.maxSize];
    }

    /**
     * 判断栈满
     */
    public boolean isFull() {
        return top == maxSize - 1;
    }

    /**
     * 判断栈空
     */
    public boolean isEmpty() {
        return top == -1;
    }

    /**
     * 入栈
     * @param value 入栈值
     */
    public void push(int value) {
        if (isFull()) {
            System.out.println("栈已经满了，无法入栈");
            return;
        }
        top++;
        stack[top] = value;
    }

    /**
     * 出栈
     * @return
     */
    public int pop() {
        if (isEmpty()) {
            throw new RuntimeException("栈已经空了，无法出栈");
        }
        int value = stack[top];
        top--;
        return value;
    }

    /**
     * 遍历栈
     */
    public void list() {
        if (isEmpty()) {
            System.out.println("栈空，没有数据");
        }
        for (int i = top; i >= 0 ; i--) {
            System.out.println("栈的第" + i + "个元素值为：" + stack[i]);
        }
    }
}
```

## 栈实现综合计算器

使用栈来实现综合计算器-自定义优先级[priority]

使用代码实现7 * 2 + 13 - 1

思路分析：

```java
1：通过一个index值(索引)，来遍历我们的字符串表达式
2：如果我们发现是一个数字，就直接入数栈
3：如果发现是一个符号，继续分析
	3.1：判断当前符号栈是否为空， 为空直接加入
	3.2 如果符号栈有操作符，进行比较，如果当前操作符的优先级小于或等于栈顶的操作符就需要从数栈中pop出两个数，并从符号栈中pop出一个符号，进行运算，再把运算结果入数栈，操作符入操作符栈
	3.3：如果符号栈有操作符，进行比较，如果当前操作符的优先级大于栈顶的操作符
4：当表达式扫描完毕，就顺序的从数栈和符号栈取出相应的数和符号，并运行
5：最后在数栈中只有一个数字，就是表达式的结果
```

代码展示：

```java
package com.paofu.data_structure.day02.stack;

/**
 * @author zhangqiang
 * @version 1.0
 * @date 2021/12/8 21:16
 * 利用栈直接计算字符串数字的结果
 * 计算思路：
 * 1：通过一个index值(索引)，来遍历我们的字符串表达式
 * 2：如果我们发现是一个数字，就直接入数栈
 * 3：如果发现是一个符号，继续分析
 * 3.1：判断当前符号栈是否为空， 为空直接加入
 * 3.2 如果符号栈有操作符，进行比较，如果当前操作符的优先级小于或等于栈顶的操作符
 * 就需要从数栈中pop出两个数，并从符号栈中pop出一个符号，进行运算，再把运算结果入数栈，操作符入操作符栈
 * 3.3：如果符号栈有操作符，进行比较，如果当前操作符的优先级大于栈顶的操作符
 * 4：当表达式扫描完毕，就顺序的从数栈和符号栈取出相应的数和符号，并运行
 * 5：最后在数栈中只有一个数字，就是表达式的结果
 */
public class Calculator {

    public static void main(String[] args) {
        String expresion = "30+2*10-2";
        // 创建两个栈，一个数字栈，一个操作符栈
        ArrayStack2 numStack = new ArrayStack2(10);
        ArrayStack2 operatorStack = new ArrayStack2(10);
        // 定义需要的相关变量
        int index = 0;
        int num1 = 0;
        int num2 = 0;
        int operator = 0;
        int res = 0;
        char ch = ' ';
        String keepNum = "";
        while (true) {
            // 依次得到每一个字符
            ch = expresion.substring(index, index + 1).charAt(0);
            if (operatorStack.isOperator(ch)) {
                // 判断当前符号栈是否为空
                if (operatorStack.isEmpty()) {
                    // 为空直接加入
                    operatorStack.push(ch);
                } else {
                    // 如果符号栈有操作符，进行比较，如果当前操作符的优先级小于或等于栈顶的操作符
                    // 就需要从数栈中pop出两个数，并从符号栈中pop出一个符号，进行运算，再把运算结果入数栈，操作符入操作符栈
                    if (operatorStack.priority(ch) <= operatorStack.priority(operatorStack.peek())) {
                        num1 = numStack.pop();
                        num2 = numStack.pop();
                        operator = operatorStack.pop();
                        res = numStack.cal(num1, num2, operator);
                        // 把结果入栈
                        numStack.push(res);
                        operatorStack.push(ch);
                    } else {
                        // 如果符号栈有操作符，进行比较，如果当前操作符的优先级大于栈顶的操作符
                        operatorStack.push(ch);
                    }
                }
            } else {
                // 根据ASCII字符表 '1'代表49 '2'代表50，所以此处入数栈需要减去48
                // 此处需要判断是几位小数，不能直接将ch入栈，否则31会变成3和1入栈
                // 在处理时，需要对expresion的index再向后一位查看，如果是数就在接着扫描，如果是符号，就拼接入栈
                // numStack.push(ch - 48);
                keepNum += ch;
                if (index == expresion.length() - 1) {
                    numStack.push(Integer.parseInt(keepNum));
                } else {
                    if (operatorStack.isOperator(expresion.substring(index + 1, index + 2).charAt(0))) {
                        numStack.push(Integer.parseInt(keepNum));
                        keepNum = "";
                    }
                }
            }
            index++;
            if (index >= expresion.length()) {
                break;
            }
        }
        // 当表达式扫描完毕，就顺序的从数栈和符号栈取出相应的数和符号，并运行
        while (true) {
            // 如果符号栈为空，则计算得到最后的结果，数栈中只有一个数字
            if (operatorStack.isEmpty()) {
                break;
            }
            num1 = numStack.pop();
            num2 = numStack.pop();
            operator = operatorStack.pop();
            res = numStack.cal(num1, num2, operator);
            numStack.push(res);
        }
        // 最后在数栈中只有一个数字，就是表达式的结果
        System.out.println("表达式：" + expresion + "的计算结果为：" + numStack.pop());

    }
}

/**
 *
 */
/**
 * 定义一个栈结构
 */
class ArrayStack2 {

    /**
     * 栈的大小
     */
    private int maxSize;

    /**
     * 数组模拟栈，数据存放在数组中
     */
    private int[] stack;

    /**
     * 栈顶  初始化为-1
     */
    private int top = -1;

    public ArrayStack2(int maxSize) {
        this.maxSize = maxSize;
        stack = new int[this.maxSize];
    }

    /**
     * 判断栈满
     */
    public boolean isFull() {
        return top == maxSize - 1;
    }

    /**
     * 判断栈空
     */
    public boolean isEmpty() {
        return top == -1;
    }

    /**
     * 入栈
     * @param value 入栈值
     */
    public void push(int value) {
        if (isFull()) {
            System.out.println("栈已经满了，无法入栈");
            return;
        }
        top++;
        stack[top] = value;
    }

    /**
     * 出栈
     * @return
     */
    public int pop() {
        if (isEmpty()) {
            throw new RuntimeException("栈已经空了，无法出栈");
        }
        int value = stack[top];
        top--;
        return value;
    }

    /**
     * 遍历栈
     */
    public void list() {
        if (isEmpty()) {
            System.out.println("栈空，没有数据");
        }
        for (int i = top; i >= 0 ; i--) {
            System.out.println("栈的第" + i + "个元素值为：" + stack[i]);
        }
    }

    /**
     * 查看栈顶的元素，但不出栈
     */
    public int peek() {
        return stack[top];
    }

    /**
     * 返回运算符的优先级
     * 优先级用数字表示，数字越大，优先级越高
     * @param operator 操作符
     */
    public int priority(int operator) {
        if (operator == '*' || operator == '/') {
            return 1;
        } else if (operator == '+' || operator == '-') {
            return 0;
        } else {
            return -1;
        }
    }

    public boolean isOperator(int operator) {
        return (operator == '*' || operator == '/' || operator == '+' || operator == '-');
    }

    /**
     * 计算方法
     * @param num1  数字1
     * @param num2  数字2
     * @param operator  操作符
     * @return
     */
    public int cal(int num1, int num2, int operator) {
        int res = 0;
        switch (operator) {
            case '+':
                res = num1 + num2;
                break;
            case '-':
                // 注意此处的顺序
                res = num2 - num1;
                break;
            case '*':
                res = num1 * num2;
                break;
            case '/':
                // 注意此处的顺序
                res = num2 / num1;
                break;
            default:
                break;
        }
        return res;
    }
}
```
## 前缀、中缀、后缀表达式(逆波兰表达式)

### 前缀表达式(波兰表达式)

1:前缀表达式又称波兰式，前缀表达式的运算符位于操作数之前

2:举例说明： (3+4)×5-6 对应的前缀表达式就是 - × + 3 4 5 6

### 前缀表达式的计算机求值

从右至左扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（栈顶元素 和 次顶元素），并将结果入栈；重复上述过程直到表达式最左端，最后运算得出的值即为表达式的结果

例如: (3+4)×5-6 对应的前缀表达式就是 - × + 3 4 5 6 , 针对前缀表达式求值步骤如下:

1：从右至左扫描，将6、5、4、3压入堆栈

2：遇到+运算符，因此弹出3和4（3为栈顶元素，4为次顶元素），计算出3+4的值，得7，再将7入栈

3：接下来是×运算符，因此弹出7和5，计算出7×5=35，将35入栈

4：最后是-运算符，计算出35-6的值，即29，由此得出最终结果

## 中缀表达式

1：中缀表达式就是常见的运算表达式，如(3+4)×5-6

2：中缀表达式的求值是我们人最熟悉的，但是对计算机来说却不好操作(前面我们讲的案例就能看的这个问题)，因此，在计算结果时，往往会将中缀表达式转成其它表达式来操作(一般转成后缀表达式.)

## 后缀表达式

1：后缀表达式又称逆波兰表达式,与前缀表达式相似，只是运算符位于操作数之后

2：举例说明： (3+4)×5-6 对应的后缀表达式就是 3 4 + 5 × 6 –

3：再比如:

| 正常的表达式 | 逆波兰表达式  |
| ------------ | ------------- |
| a+b          | a b +         |
| a+(b-c)      | a b c - +     |
| a+(b-c)*d    | a b c – d * + |
| a+d*(b-c)    | a d b c - * + |
| a=1+3        | a 1 3 + =     |

### 后缀表达式的计算机求值

**从左至右扫描表达式**，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（次顶元素 和 栈顶元素），并将结果入栈；重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果

例如: (3+4)×5-6 对应的后缀表达式就是 3 4 + 5 × 6 - , 针对后缀表达式求值步骤如下:

1：从左至右扫描，将3和4压入堆栈；

2：遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈；

3：将5入栈；

4：接下来是×运算符，因此弹出5和7，计算出7×5=35，将35入栈；

5：将6入栈；

6：最后是-运算符，计算出35-6的值，即29，由此得出最终结果

代码展示：

```
package com.paofu.data_structure.day02.stack;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Stack;

/**
 * @author zhangqiang
 * @version 1.0
 * @date 2021/12/9 19:20
 * 逆波兰表达式
 */
public class PolandNotation {

    public static void main(String[] args) {
        // 定义一个逆波兰表达式
        // (3+4)*5-6 -->  3 4 + 5 * 6 - 为了方便，逆波兰表达式的数字和符号使用空格隔开
        String suffixExpression = "3 4 + 5 * 6 - ";
        // 1：先将suffixExpression放入arrayList
        System.out.println(getListString(suffixExpression));
        // 2：将arrayList传递给一个方法，配合栈，完成计算
        System.out.println("逆波兰表达式：" + suffixExpression + "的结果为：" + calculate(getListString(suffixExpression)));
    }

    /**
     * 将逆波兰表达式，依次将数据和运算符放入到arrayList中
     */
    public static List<String> getListString(String suffixExpression) {
        String[] split = suffixExpression.split(" ");
        return new ArrayList<>(Arrays.asList(split));
    }

    /**
     * 完成对逆波兰表达式的计算
     */
    public static int calculate(List<String> list) {
        Stack<String> stack = new Stack<String>();
        for (String s : list) {
            // 使用正则表达式取出数
            if (s.matches("\\d+")) {
                stack.push(s);
            } else {
                // pop出两个数并运算，并将结果入栈
                int num2 = Integer.parseInt(stack.pop());
                int num1 = Integer.parseInt(stack.pop());
                int res = 0;
                if ("+".equals(s)) {
                    res = num1 + num2;
                } else if ("-".equals(s)) {
                    res = num1 - num2;
                } else if ("*".equals(s)) {
                    res = num1 * num2;
                } else if ("/".equals(s)) {
                    res = num1 / num2;
                } else {
                    throw new RuntimeException("未知的操作符");
                }
                stack.push("" + res);
            }
        }
        return Integer.parseInt(stack.pop());
    }
}
```

## 逆波兰计算器

### 我们完成一个逆波兰计算器，要求完成如下任务:

1：输入一个逆波兰表达式(后缀表达式)，使用栈(Stack), 计算其结果

2：支持小括号和多位数整数，因为这里我们主要讲的是数据结构，因此计算器进行简化，只支持对整数的计算。

3：思路分析

### 中缀表达式转换为后缀表达式

大家看到，后缀表达式适合计算式进行运算，但是人却不太容易写出来，尤其是表达式很长的情况下，因此在开发中，我们需要将 中缀表达式转成后缀表达式。

具体步骤如下：

#### 1：初始化两个栈：运算符栈s1和储存中间结果的栈s2；

#### 2：从左至右扫描中缀表达式；

#### 3：遇到操作数时，将其压s2；

#### 4：遇到运算符时，比较其与s1栈顶运算符的优先级：

##### 4.1：如果s1为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈；

##### 4.2：否则，若优先级比栈顶运算符的高，也将运算符压入s1；

##### 4.3：否则，将s1栈顶的运算符弹出并压入到s2中，再次转到(4-1)与s1中新的栈顶运算符相比较；

#### 5：遇到括号时：

##### 5.1：如果是左括号“(”，则直接压入s1

##### 5.2：如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃

#### 6：重复步骤2至5，直到表达式的最右边

#### 7：将s1中剩余的运算符依次弹出并压入s2

#### 8：依次弹出s2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式

举例说明:

将中缀表达式“1+((2+3)×4)-5”转换为后缀表达式的过程如下

| 扫描到的元素 | s2(栈底->栈顶)    | s1 (栈底->栈顶) | 说明                               |
| ------------ | ----------------- | --------------- | ---------------------------------- |
| 1            | 1                 | 空              | 数字，直接入栈                     |
| +            | 1                 | +               | s1为空，运算符直接入栈             |
| (            | 1                 | + (             | 左括号，直接入栈                   |
| (            | 1                 | + ( (           | 同上                               |
| 2            | 1 2               | + ( (           | 数字                               |
| +            | 1 2               | + ( ( +         | s1栈顶为左括号，运算符直接入栈     |
| 3            | 1 2 3             | + ( ( +         | 数字                               |
| )            | 1 2 3 +           | + (             | 右括号，弹出运算符直至遇到左括号   |
| ×            | 1 2 3 +           | + ( ×           | s1栈顶为左括号，运算符直接入栈     |
| 4            | 1 2 3 + 4         | + ( ×           | 数字                               |
| )            | 1 2 3 + 4 ×       | +               | 右括号，弹出运算符直至遇到左括号   |
| -            | 1 2 3 + 4 × +     | -               | -与+优先级相同，因此弹出+，再压入- |
| 5            | 1 2 3 + 4 × + 5   | -               | 数字                               |
| 到达最右端   | 1 2 3 + 4 × + 5 - | 空              | s1中剩余的运算符                   |



4：代码完成

```
package com.paofu.data_structure.day02.stack;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Stack;

/**
 * @author zhangqiang
 * @version 1.0
 * @date 2021/12/9 19:20
 * 逆波兰表达式
 */
public class PolandNotation {

    public static void main(String[] args) {
        // 定义一个逆波兰表达式
        // (3+4)*5-6 -->  3 4 + 5 * 6 - 为了方便，逆波兰表达式的数字和符号使用空格隔开
        String suffixExpression = "3 4 + 5 * 6 - ";
        // 1：先将suffixExpression放入arrayList
        System.out.println(getListString(suffixExpression));
        // 2：将arrayList传递给一个方法，配合栈，完成计算
        System.out.println("逆波兰表达式：" + suffixExpression + "的结果为：" + calculate(getListString(suffixExpression)));
        // 完成将一个中缀表达式转成后缀表达式
        // 如将 1+((2+3)*4)-5的中缀表达式转成 1 2 3 + 4 * + 5 -
        // 直接对字符串进行扫描，不方便，先将字符串转成中缀的集合
        String expression = "1+((2+3)*4)-5";
        // 将中缀表达式转为集合  [1, +, (, (, 2, +, 3, ), *, 4, ), -, 5]
        List<String> infixList = toInfixExpressionList(expression);
        System.out.println(infixList);
        // 将中缀表达式集合转为后缀表达式集合  [1, 2, 3, +, 4, *, +, 5, -]
        List<String> suffixList = parseSuffixExpression(infixList);
        System.out.println(suffixList);
        // 计算值
        int calculate = calculate(suffixList);
        System.out.println("逆波兰表达式：" + suffixList + "的计算结果为：" + calculate);
    }

    /**
     * 将逆波兰表达式，依次将数据和运算符放入到arrayList中
     */
    public static List<String> getListString(String suffixExpression) {
        String[] split = suffixExpression.split(" ");
        return new ArrayList<>(Arrays.asList(split));
    }

    /**
     * 完成对逆波兰表达式的计算
     */
    public static int calculate(List<String> list) {
        Stack<String> stack = new Stack<String>();
        for (String s : list) {
            // 使用正则表达式取出数
            if (s.matches("\\d+")) {
                stack.push(s);
            } else {
                // pop出两个数并运算，并将结果入栈
                int num2 = Integer.parseInt(stack.pop());
                int num1 = Integer.parseInt(stack.pop());
                int res = 0;
                if ("+".equals(s)) {
                    res = num1 + num2;
                } else if ("-".equals(s)) {
                    res = num1 - num2;
                } else if ("*".equals(s)) {
                    res = num1 * num2;
                } else if ("/".equals(s)) {
                    res = num1 / num2;
                } else {
                    throw new RuntimeException("未知的操作符");
                }
                stack.push("" + res);
            }
        }
        return Integer.parseInt(stack.pop());
    }

    /**
     * 将字符串中缀表达式转为集合存放
     * @param expression  中缀表达式
     * @return  List<String>
     */
    public static List<String> toInfixExpressionList(String expression) {
        List<String> list = new ArrayList<>();
        int i = 0;
        String str;
        char ch;
        do {
            if ((ch =expression.charAt(i)) < 48 || (ch =expression.charAt(i)) > 57) {
                list.add("" + ch);
                i++;
            } else {
                // 考虑多位数拼接的问题
                str = "";
                while (i < expression.length() && ((ch =expression.charAt(i)) >= 48 && (ch =expression.charAt(i)) <= 57)) {
                    str += ch;
                    i++;
                }
                list.add(str);
            }
        } while (i < expression.length());
        return list;
    }

    /**
     * 将中缀表达式的list转换为后缀表达式的list
     * @param list  中缀表达式的list
     * @return  后缀表达式的list
     */
    public static List<String> parseSuffixExpression(List<String> list) {
        // 初始化栈
        Stack<String> stack = new Stack<>();
        // stack2在整个过程中没有pop的操作，并且后续需要逆序，所以此处直接使用arrayList
        List<String> resultList = new ArrayList<>();

        // 遍历list
        for (String data : list) {
            // 如果是一个数，直接入栈，即resultList
            if (data.matches("\\d+")) {
                resultList.add(data);
            } else if (("(").equals(data)) {
                // 如果是左括号“(”，则直接压入s1
                stack.push(data);
            } else if ((")").equals(data)) {
                // 如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃
                while (!("(".equals(stack.peek()))) {
                    resultList.add(stack.pop());
                }
                // 将栈中的"("弹出消除掉
                stack.pop();
            } else {
                // 当data的运算优先级小于或等于栈顶运算符的优先级
                // 将s1栈顶的运算符弹出并压入到s2中(resultList)，再次与s1中新的栈顶运算符相比较
                while (stack.size() != 0 && (getValue(data) <= getValue(stack.peek()))) {
                    resultList.add(stack.pop());
                }
                // 将data压入stack
                stack.push(data);
            }
        }
        // 将stack中剩余的运算符依次弹出并加入resultList
        while (!stack.isEmpty()) {
            resultList.add(stack.pop());
        }
        return resultList;
    }

    /**
     * 返回对应的优先级数字
     */
    public static int getValue(String operator) {
        int result = 0;
        switch (operator) {
            case "+":
            case "-":
                result = 1;
                break;
            case "*":
            case "/":
                result = 2;
                break;
            default:
                break;
        }
        return result;
    }
}
```

## 逆波兰计算器完整版

完整版的逆波兰计算器，功能包括:

1：支持 + - * / ( )  多位数，

2：支持小数,

3：兼容处理, 过滤任何空白字符，包括空格、制表符、换页符

代码如下：

```java
package com.paofu.data_structure.day02.stack;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Stack;
import java.util.regex.Pattern;

/**
 * @author zhangqiang
 * @version 1.0
 * @date 2021/12/9 21:20
 * 完整的逆波兰计算器代码
 */
public class ReversePolishMultiCalc {

    /**
     * 匹配 + - * / ( ) 运算符
     */
    static final String SYMBOL = "\\+|-|\\*|/|\\(|\\)";

    static final String LEFT = "(";
    static final String RIGHT = ")";
    static final String ADD = "+";
    static final String MINUS= "-";
    static final String TIMES = "*";
    static final String DIVISION = "/";

    /**
     * 加減 + -
     */
    static final int LEVEL_01 = 1;
    /**
     * 乘除 * /
     */
    static final int LEVEL_02 = 2;

    /**
     * 括号
     */
    static final int LEVEL_HIGH = Integer.MAX_VALUE;


    static Stack<String> stack = new Stack<>();
    static List<String> data = Collections.synchronizedList(new ArrayList<String>());

    /**
     * 去除所有空白符
     * @param s
     * @return
     */
    public static String replaceAllBlank(String s ){
        // \\s+ 匹配任何空白字符，包括空格、制表符、换页符等等, 等价于[ \f\n\r\t\v]
        return s.replaceAll("\\s+","");
    }

    /**
     * 判断是不是数字 int double long float
     * @param s
     * @return
     */
    public static boolean isNumber(String s){
        Pattern pattern = Pattern.compile("^[-\\+]?[.\\d]*$");
        return pattern.matcher(s).matches();
    }

    /**
     * 判断是不是运算符
     * @param s
     * @return
     */
    public static boolean isSymbol(String s){
        return s.matches(SYMBOL);
    }

    /**
     * 匹配运算等级
     * @param s
     * @return
     */
    public static int calcLevel(String s){
        if("+".equals(s) || "-".equals(s)){
            return LEVEL_01;
        } else if("*".equals(s) || "/".equals(s)){
            return LEVEL_02;
        }
        return LEVEL_HIGH;
    }

    /**
     * 匹配
     * @param s
     * @throws Exception
     */
    public static List<String> doMatch (String s) throws Exception{
        if(s == null || "".equals(s.trim())) throw new RuntimeException("data is empty");
        if(!isNumber(s.charAt(0)+"")) throw new RuntimeException("data illeagle,start not with a number");

        s = replaceAllBlank(s);

        String each;
        int start = 0;

        for (int i = 0; i < s.length(); i++) {
            if(isSymbol(s.charAt(i)+"")){
                each = s.charAt(i)+"";
                //栈为空，(操作符，或者 操作符优先级大于栈顶优先级 && 操作符优先级不是( )的优先级 及是 ) 不能直接入栈
                if(stack.isEmpty() || LEFT.equals(each)
                        || ((calcLevel(each) > calcLevel(stack.peek())) && calcLevel(each) < LEVEL_HIGH)){
                    stack.push(each);
                }else if( !stack.isEmpty() && calcLevel(each) <= calcLevel(stack.peek())){
                    //栈非空，操作符优先级小于等于栈顶优先级时出栈入列，直到栈为空，或者遇到了(，最后操作符入栈
                    while (!stack.isEmpty() && calcLevel(each) <= calcLevel(stack.peek()) ){
                        if(calcLevel(stack.peek()) == LEVEL_HIGH){
                            break;
                        }
                        data.add(stack.pop());
                    }
                    stack.push(each);
                }else if(RIGHT.equals(each)){
                    // ) 操作符，依次出栈入列直到空栈或者遇到了第一个)操作符，此时)出栈
                    while (!stack.isEmpty() && LEVEL_HIGH >= calcLevel(stack.peek())){
                        if(LEVEL_HIGH == calcLevel(stack.peek())){
                            stack.pop();
                            break;
                        }
                        data.add(stack.pop());
                    }
                }
                start = i ;    //前一个运算符的位置
            }else if( i == s.length()-1 || isSymbol(s.charAt(i+1)+"") ){
                each = start == 0 ? s.substring(start,i+1) : s.substring(start+1,i+1);
                if(isNumber(each)) {
                    data.add(each);
                    continue;
                }
                throw new RuntimeException("data not match number");
            }
        }
        //如果栈里还有元素，此时元素需要依次出栈入列，可以想象栈里剩下栈顶为/，栈底为+，应该依次出栈入列，可以直接翻转整个stack 添加到队列
        Collections.reverse(stack);
        data.addAll(new ArrayList<>(stack));

        System.out.println(data);
        return data;
    }

    /**
     * 算出结果
     * @param list
     * @return
     */
    public static Double doCalc(List<String> list){
        Double d = 0d;
        if(list == null || list.isEmpty()){
            return null;
        }
        if (list.size() == 1){
            System.out.println(list);
            d = Double.valueOf(list.get(0));
            return d;
        }
        ArrayList<String> list1 = new ArrayList<>();
        for (int i = 0; i < list.size(); i++) {
            list1.add(list.get(i));
            if(isSymbol(list.get(i))){
                Double d1 = doTheMath(list.get(i - 2), list.get(i - 1), list.get(i));
                list1.remove(i);
                list1.remove(i-1);
                list1.set(i-2,d1+"");
                list1.addAll(list.subList(i+1,list.size()));
                break;
            }
        }
        doCalc(list1);
        return d;
    }

    /**
     * 运算
     * @param s1
     * @param s2
     * @param symbol
     * @return
     */
    public static Double doTheMath(String s1,String s2,String symbol){
        Double result ;
        switch (symbol){
            case ADD : result = Double.valueOf(s1) + Double.valueOf(s2); break;
            case MINUS : result = Double.valueOf(s1) - Double.valueOf(s2); break;
            case TIMES : result = Double.valueOf(s1) * Double.valueOf(s2); break;
            case DIVISION : result = Double.valueOf(s1) / Double.valueOf(s2); break;
            default : result = null;
        }
        return result;

    }

    public static void main(String[] args) {
        //String math = "9+(3-1)*3+10/2";
        String math = "12.8 + (2 - 3.55)*4+10/5.0";
        try {
            doCalc(doMatch(math));
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

}
```
# 递归

## 1.1 概念

简单的说: 递归就是方法自己调用自己,每次调用时传入不同的变量.递归有助于编程者解决复杂的问题,同时可以让代码变得简洁。

## 1.2 递归经典调用：

### 1.2.1 打印问题

代码展示：

```
package com.paofu.data_structure.day02.recursion;

/**
 * @author zhangqiang
 * @version 1.0
 * @date 2021/12/13 19:25
 * 测试递归
 */
public class RecursionTest {

    public static void main(String[] args) {
        // 此处注意三种方法打印出来的结果不同，由于调用执行的顺序不一样
        test1(10);
        System.out.println("----------------------");
        test2(10);
        System.out.println("----------------------");
        test3(10);
    }

    public static void test1(int num) {
        if (num >= 0) {
            test1(num - 1);
            System.out.println("当前打印数字是：" + num);
        }
    }

    public static void test2(int num) {
        if (num >= 0) {
            System.out.println("当前打印数字是：" + num);
            test2(num - 1);
        }
    }

    public static void test3(int num) {
        if (num >= 0) {
            test3(num - 1);
        }
        System.out.println("当前打印数字是：" + num);
    }
}
```

### 1.2.2  阶乘问题

代码：

```
package com.paofu.data_structure.day02.recursion;

/**
 * @author zhangqiang
 * @version 1.0
 * @date 2021/12/13 19:25
 * 测试递归
 */
public class RecursionTest {

    public static void main(String[] args) {
        System.out.println("10的阶乘是：" + test4(10));
    }

    public static int test4(int num) {
        if (num == 1) {
            return 1;
        } else {
            return test4(num - 1) * num;
        }
    }
}
```

## 1.3 递归调用机制

递归调用规则：

1：当程序执行到一个方法时，就会开辟一个独立的空间(栈)

2：每个空间的数据(局部变量)，是独立的

图解：

![1639404294788](D:\360MoveData\Users\25502\Desktop\数据结构\assets\1639404294788.png)

![1639404305898](D:\360MoveData\Users\25502\Desktop\数据结构\assets\1639404305898.png)

## 1.4 递归能解决什么样的问题

1：各种数学问题如: 8皇后问题 , 汉诺塔, 阶乘问题, 迷宫问题, 球和篮子的问题

2：各种算法中也会使用到递归，比如快排，归并排序，二分查找，分治算法等

3：将用栈解决的问题-->递归代码比较简洁

## 1.5 递归需要遵守的重要规则

1：执行一个方法时，就创建一个新的受保护的独立空间(栈空间)

2：方法的局部变量是独立的，不会相互影响, 比如n变量

3：如果方法中使用的是引用类型变量(比如数组)，就会共享该引用类型的数据

4：递归必须向退出递归的条件逼近，否则就是无限递归,出现StackOverflowError

5：当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕

## 1.6 迷宫问题

说明：

1：小球得到的路径，和程序设置的找路策略有关即：找路的上下左右的顺序相关

2：再得到小球路径时，可以先使用(下右上左)，再改成(上右下左)，看看路径是不是有变化

代码展示：

```
package com.paofu.data_structure.day02.recursion;

/**
 * @author zhangqiang
 * @version 1.0
 * @date 2021/12/13 19:53
 * 迷宫问题
 */
public class MiGong {

    public static void main(String[] args) {
        // 先创建一个二维数组，模拟迷宫
        int[][] map = new int[8][7];
        // 使用1，表示墙，不能经过
        // 上下全部置为1
        for (int i = 0; i < 7; i++) {
            map[0][i] = 1;
            map[7][i] = 1;
        }
        // 左右全部置为1
        for (int i = 0; i < 8; i++) {
            map[i][0] = 1;
            map[i][6] = 1;
        }
        // 设置挡板
        map[3][1] = 1;
        map[3][2] = 1;
//        map[1][2] = 1;
//        map[2][2] = 1;
        // 遍历
        System.out.println("地图的展示-------->");
        for (int i = 0; i < 8; i++) {
            for (int j = 0; j < 7; j++) {
                System.out.print(map[i][j] + " ");
            }
            System.out.println();
        }

        System.out.println(findWay1(map, 1, 1));

        // 遍历
        System.out.println("小球走过并标识过的地图-------->");
        for (int i = 0; i < 8; i++) {
            for (int j = 0; j < 7; j++) {
                System.out.print(map[i][j] + " ");
            }
            System.out.println();
        }
    }

    /**
     * 使用递归回调给小球找路
     * i j 表示map[i][j]开始找
     * 如果小球能到map[6][5](终点)即找到
     * 约定 map[i][j] = 0时代表没有走过,1表示墙，2表示可以走 3表示该点已经走过，但走不通
     * 在开始前需要确定一个策略(方法) 下->右->上->左,如果该点走不通在回溯
     * @param map  地图
     * @param i  从哪开始找
     * @param j  从哪开始找
     * @return boolean
     */
    public static boolean findWay(int[][] map, int i, int j) {
        if (map[6][5] == 2) {
            return true;
        } else {
            // 当前点没有走过
            if (map[i][j] == 0) {
                // 按照策略走  下->右->上->左
                // 假设该点可以走
                map[i][j] = 2;
                // 向下走
                if (findWay(map, i + 1, j)) {
                    return true;
                } else if (findWay(map, i, j + 1)){
                    return true;
                } else if ( findWay(map, i - 1, j)){
                   return true;
                }  else if (findWay(map, i, j - 1)) {
                    return true;
                } else {
                    // 上下左右都走不通
                    map[i][j] = 3;
                    return false;
                }
            } else {
                return false;
            }
        }
    }

    /**
     * 使用递归回调给小球找路
     * i j 表示map[i][j]开始找
     * 如果小球能到map[6][5](终点)即找到
     * 约定 map[i][j] = 0时代表没有走过,1表示墙，2表示可以走 3表示该点已经走过，但走不通
     * 修改策略(方法) 上->右->下->左,如果该点走不通在回溯
     * @param map  地图
     * @param i  从哪开始找
     * @param j  从哪开始找
     * @return boolean
     */
    public static boolean findWay1(int[][] map, int i, int j) {
        if (map[6][5] == 2) {
            return true;
        } else {
            // 当前点没有走过
            if (map[i][j] == 0) {
                // 按照策略走  下->右->上->左
                // 假设该点可以走
                map[i][j] = 2;
                // 向下走
                if (findWay1(map, i - 1, j)) {
                    return true;
                } else if (findWay1(map, i, j + 1)){
                    return true;
                } else if ( findWay1(map, i + 1, j)){
                    return true;
                }  else if (findWay1(map, i, j - 1)) {
                    return true;
                } else {
                    // 上下左右都走不通
                    map[i][j] = 3;
                    return false;
                }
            } else {
                return false;
            }
        }
    }
}
```

思考：如何求出最短路径? 

## 1.7 八皇后问题(回溯算法)

八皇后问题介绍 ：

八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于1848年提出：在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即：任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。

图示：

![1639404465754](D:\360MoveData\Users\25502\Desktop\数据结构\assets\1639404465754.png)

思路分析：

1：第一个皇后先放第一行第一列

2：第二个皇后放在第二行第一列、然后判断是否OK， 如果不OK，继续放在第二列、第三列、依次把所有列都放完，找到一个合适

3：继续第三个皇后，还是第一列、第二列……直到第8个皇后也能放在一个不冲突的位置，算是找到了一个正确解

4：当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解，全部得到.

5：然后回头继续第一个皇后放第二列，后面继续循环执行 1,2,3,4的步骤 

说明：

理论上应该创建一个二维数组来表示棋盘，但是实际上可以通过算法，用一个一维数组即可解决问题.。如arr[8] = {0 , 4, 7, 5, 2, 6, 1, 3} 

对应arr 下标 表示第几行，即第几个皇后，arr[i] = val , val 表示第i+1个皇后，放在第i+1行的第val+1列

代码展示：

```
package com.paofu.data_structure.day02.recursion;

/**
 * @author zhangqiang
 * @version 1.0
 * @date 2021/12/13 21:04
 * 八皇后问题
 */
public class EightQueue {

    /**
     * 定义一个max表示共有几个皇后
     */
    public static int MAX = 8;

    /**
     * 定义数组，保存皇后放置位置的结果
     */
    public static int[] ARRAY = new int[MAX];

    public static int count = 0;

    public static void main(String[] args) {
        putQueue(0);
        System.out.println("八皇后一共有" + count + "种解法");
    }

    /**
     * 将皇后摆放的位置输出
     */
    public static void print() {
        for (int i = 0; i < ARRAY.length; i++) {
            System.out.print(ARRAY[i] + " ");
        }
        System.out.println();
        count++;
    }

    /**
     * 判断当我们放置第n个皇后时，是否和前面n-1个皇后冲突
     * @param num 代表第n个皇后
     * @return boolean
     */
    public static boolean judgeConflict(int num) {
        for (int i = 0; i < num; i++) {
            // ARRAY[i] == ARRAY[num] 判断第n个皇后是否和前面的n-1个皇后在同一列
            // Math.abs(num - i)  == Math.abs(ARRAY[num] - ARRAY[i]) 第num个皇后是否和第i个皇后在同一斜线
            if (ARRAY[i] == ARRAY[num] || Math.abs(num - i)  == Math.abs(ARRAY[num] - ARRAY[i])) {
                return false;
            }
        }
        return true;
    }

    /**
     * 放置第n个皇后
     */
    public static void putQueue(int num) {
        if (num == MAX) {
            print();
            return;
        }
        // 依次放入皇后并判断是否冲突
        for (int i = 0; i < MAX; i++) {
            // 先把当前皇后(n)放到该行的第一列上
            ARRAY[num] = i;
            // 判断是否冲突
            if (judgeConflict(num)) {
                // 接着放置n+1个皇后，开始递归
                putQueue(num + 1);
            }
            // 如果冲突，继续执行array[num] = i,即接着进入for循环
        }
    }
}
```

# 排序算法

## 1.1：介绍

排序也称排序算法(Sort Algorithm)，排序是将一组数据，依指定的顺序进行排列的过程。

排序的分类:

内部排序: 指将需要处理的所有数据都加载到内部存储器中进行排序

外部排序法：数据量过大，无法全部加载到内存中，需要借助外部存储进行排序。

常见的排序算法分类：

| 内部排序 | 插入排序 | 直接插入排序 |
| :------: | :------: | :----------: |
|          |          |   希尔排序   |
|          | 选择排序 | 简单选择排序 |
|          |          |    堆排序    |
|          | 交换排序 |   冒泡排序   |
|          |          |   快速排序   |
|          | 归并排序 |              |
|          | 基数排序 |              |
| 外部排序 |          |              |

![1639488542786](D:\360MoveData\Users\25502\Desktop\数据结构\assets\1639488542786.png)

## 1.2: 算法的时间复杂度

### 1.2.1 度量一个程序(算法)执行时间的两种方法:

1：事后统计的方法这种方法可行, 但是有两个问题：一是要想对设计的算法的运行性能进行评测，需要实际运行该程序；二是所得时间的统计量依赖于计算机的硬件、软件等环境因素, 这种方式，要在同一台计算机的相同状态下运行，才能比较那个算法速度更快

2：事前估算的方法通过分析某个算法的时间复杂度来判断哪个算法更优

时间频度：一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)

### 1.2.2 时间复杂度：

1：一般情况下，算法中的基本操作语句的重复执行次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n)，使得当n趋近于无穷大时，T(n) / f(n) 的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作 T(n)=Ｏ( f(n) )，称Ｏ( f(n) )  为算法的渐进时间复杂度，简称时间复杂度

2：T(n) 不同，但时间复杂度可能相同。 如：T(n)=n²+7n+6 与 T(n)=3n²+2n+2 它们的T(n) 不同，但时间复杂度相同，都为O(n²)

3：计算时间复杂度的方法：

​	3.1：用常数1代替运行时间中的所有加法常数  T(n)=n²+7n+6  => T(n)=n²+7n+1

​	3.2：修改后的运行次数函数中，只保留最高阶项  T(n)=n²+7n+1 => T(n) = n²

​	3.3：去除最高阶项的系数 T(n) = n² => T(n) = n² => O(n²)

### 1.3.3 常见的时间复杂度：

| 常数阶O(1)          | 无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1) |
| :------------------ | ------------------------------------------------------------ |
| 对数阶O(log2n)      | 在while循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了。假设循环x次之后，i 就大于 2 了，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 x = log2n也就是说当循环 log2n 次以后，这个代码就结束了。因此这个代码的时间复杂度为：O(log2n) |
| 线性阶O(n)          | for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的，因此这类代码都可以用O(n)来表示它的时间复杂度 |
| 线性对数阶O(nlog2n) | 线性对数阶O(nlogN) 其实非常容易理解，将时间复杂度为O(logn)的代码循环N遍的话，那么它的时间复杂度就是 n * O(logN)，也就是了O(nlogN) |
| 平方阶O(n^2)        | 平方阶O(n²) 就更容易理解了，如果把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²)，这段代码其实就是嵌套了2层n循环，它的时间复杂度就是 O(n*n)，即  O(n²) 如果将其中一层循环的n改成m，那它的时间复杂度就变成了 O(m*n) |
| 立方阶O(n^3)        | 参考上面的O(n²) 去理解就好了，O(n³)相当于三层n循环，其它的类似 |
| k次方阶O(n^k)       | 参考上面的O(n²) 去理解就好了，O(n³)相当于三层n循环，其它的类似 |
| 指数阶O(2^n)        |                                                              |
| 阶乘阶O(n!)         |                                                              |

说明：常见的算法时间复杂度由小到大依次为：Ο(1)＜Ο(log2n)＜Ο(n)＜Ο(nlog2n)＜Ο(n2)＜Ο(n3)＜ Ο(nk) ＜Ο(2n) ，随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低



### 1.3.4 平均时间复杂度和最坏时间复杂度：

1：平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间

2：最坏情况下的时间复杂度称最坏时间复杂度。一般讨论的时间复杂度均是最坏情况下的时间复杂度。 这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的界限，这就保证了算法的运行时间不会比最坏情况更长

3：平均时间复杂度和最坏时间复杂度是否一致，和算法有关

| 排序法   | 平均时间   | 最差情形     | 稳定度 | 额外空间 | 备注                         |
| -------- | ---------- | ------------ | ------ | -------- | ---------------------------- |
| 冒泡排序 | O(n^2)     | O(n^2)       | 稳定   | O(1)     | n小时较好                    |
| 交换排序 | O(n^2)     | O(n^2)       | 不稳定 | O(1)     | n小时较好                    |
| 选择排序 | O(n^2)     | O(n^2)       | 不稳定 | O(1)     | n小时较好                    |
| 插入排序 | O(n^2)     | O(n^2)       | 稳定   | O(1)     | 大部分已排序较好             |
| 基数排序 | O(log R B) | O(log R B)   | 稳定   | O(n)     | B是真数(0-9) R是基数(个十百) |
| 希尔排序 | O(nlogn)   | O(n^s) 1<s<2 | 不稳定 | O(1)     | s是所选分组                  |
| 快速排序 | O(nlogn)   | O(n^2)       | 不稳定 | O(nlogn) | n大时较好                    |
| 归并排序 | O(nlogn)   | O(nlogn)     | 稳定   | O(1)     |                              |
| 堆排序   | O(nlogn)   | O(nlogn)     | 不稳定 | O(1)     |                              |

![1639489211894](D:\360MoveData\Users\25502\Desktop\数据结构\assets\1639489211894.png)

## 1.3 算法的空间复杂度

基本介绍：

1：类似于时间复杂度的讨论，一个算法的空间复杂度(Space Complexity)定义为该算法所耗费的存储空间，它也是问题规模n的函数

2：空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。有的算法需要占用的临时工作单元数与解决问题的规模n有关，它随着n的增大而增大，当n较大时，将占用较多的存储单元，例如快速排序和归并排序算法就属于这种情况

3：在做算法分析时，主要讨论的是时间复杂度。从用户使用体验上看，更看重的程序执行的速度。一些缓存产品(redis, memcache)和算法(基数排序)本质就是用空间换时间

## 1.4 冒泡排序

介绍：冒泡排序（Bubble Sorting）的基本思想是：通过对待排序序列从前向后（从下标较小的元素开始）,依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒

优化分析：

因为排序的过程中，各元素不断接近自己的位置，如果一趟比较下来没有进行过交换，就说明序列有序，因此要在排序过程中设置一个标志flag判断元素是否进行过交换。从而减少不必要的比较。(这里说的优化，可以在冒泡排序写好后，在进行)

步骤演示：

原始数组：3, 9, -1, 10, 20第一趟排序(1)  3, 9, -1, 10, 20   // 如果相邻的元素逆序就交换(2)  3, -1, 9, 10, 20(3)  3, -1, 9, 10, 20(4)  3, -1, 9, 10, 20第二趟排序(1) -1, 3, 9, 10, 20 //交换(2) -1, 3, 9, 10, 20(3) -1, 3, 9, 10, 20第三趟排序(1) -1, 3, 9, 10, 20(2) -1, 3, 9, 10, 20第四趟排序(1) -1, 3, 9, 10, 20小结冒泡排序规则(1) 一共进行 数组的大小-1 次 大的循环(2)每一趟排序的次数在逐渐的减少(3) 如果我们发现在某趟排序中，没有发生一次交换， 可以提前结束冒泡排序。这个就是优化

代码展示：

```
package com.paofu.data_structure.day03.sort;

import java.util.Arrays;

/**
 * @author zhangqiang
 * @version 1.0
 * @date 2021/12/14 20:06
 * 冒泡排序示例  时间复杂度 O(n^2)
 */
public class BubbleSort {

    public static void main(String[] args) {
        int[] array = {3, 9, -1, 10, -2};
        bubbleSort(array);
        bubbleSort1(array);
    }

    public static void bubbleSort(int[] array) {
        int temp = 0;
        for (int i = 0; i < array.length - 1; i++) {
            for (int j = 0; j < array.length - i - 1; j++) {
                if (array[j] > array[j + 1]) {
                    temp = array[j];
                    array[j] = array[j + 1];
                    array[j + 1] = temp;
                }
            }
            System.out.println("第" + (i + 1) + "次排序后的数组为：" + Arrays.toString(array));
        }
    }

    /**
     * 优化冒泡排序，减少不必要的比较
     * @param array  数组
     */
    public static void bubbleSort1(int[] array) {
        int temp = 0;
        // 表示是否进行过交换
        boolean flag = false;
        for (int i = 0; i < array.length - 1; i++) {
            for (int j = 0; j < array.length - i - 1; j++) {
                if (array[j] > array[j + 1]) {
                    flag = true;
                    temp = array[j];
                    array[j] = array[j + 1];
                    array[j + 1] = temp;
                }
            }
            System.out.println("第" + (i + 1) + "次排序后的数组为：" + Arrays.toString(array));
            if (!flag) {
                // 表示在一趟排序中一次交换都没发生
                break;
            } else {
                flag = false;
            }
        }
    }
}
```

## 1.5 选择排序

介绍：选择式排序也属于内部排序法，是从欲排序的数据中，按指定的规则选出某一元素，再依规定交换位置后达到排序的目的

思想分析：选择排序（select sorting）也是一种简单的排序方法。它的基本思想是：第一次从arr[0] ~ arr[n-1]中选取最小值，与arr[0]交换，第二次从arr[1]~arr[n-1]中选取最小值，与arr[1]交换，第三次从arr[2] ~ arr[n-1]中选取最小值，与arr[2]交换，…，第i次从arr[i-1]~arr[n-1]中选取最小值，与arr[i-1]交换，…, 第n-1次从arr[n-2]~arr[n-1]中选取最小值，与arr[n-2]交换，总共通过n-1次，得到一个按排序码从小到大排列的有序序列

代码展示：

```
package com.paofu.data_structure.day03.sort;

import java.util.Arrays;

/**
 * @author zhangqiang
 * @version 1.0
 * @date 2021/12/14 20:47
 * 选择排序 时间复杂度也是O(n^2)
 */
public class SelectSort {

    public static void main(String[] args) {
        int[] array = {101, 34, 119, 1};
        selectSort(array);
    }

    public static void selectSort(int[] array) {
        for (int i = 0; i < array.length - 1; i++) {
            int minIndex = i;
            int min = array[i];
            for (int j = i + 1; j < array.length; j++) {
                if (array[j] < min) {
                    min = array[j];
                    minIndex = j;
                }
            }
            if (minIndex != i) {
                array[minIndex] = array[i];
                array[i] = min;
            }
            System.out.println("第" + (i + 1) + "次排序后的数组为：" + Arrays.toString(array));
        }

    }
}
```

## 1.6 插入排序

介绍：插入式排序属于内部排序法，是对于欲排序的元素以插入的方式找寻该元素的适当位置，以达到排序的目的

思想：插入排序（Insertion Sorting）的基本思想是：把n个待排序的元素看成为一个有序表和一个无序表，开始时有序表中只包含一个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表

思路图：

![1639575972081](D:\360MoveData\Users\25502\Desktop\数据结构\assets\1639575972081.png)

代码展示：

```java
package com.paofu.data_structure.day03.sort;

import java.util.Arrays;

/**
 * @author zhangqiang
 * @version 1.0
 * @date 2021/12/14 21:06
 * 插入排序  时间复杂度也是O(n^2)
 */
public class InsertSort {

    public static void main(String[] args) {
        int[] array = {101, 34, 119, 1};
        int[] testArray = new int[80000];
        for (int i = 0; i < 80000; i++) {
            testArray[i] = (int) (Math.random() * 80000);
        }
        insertSort(testArray);
    }

    public static void insertSort(int[] array) {
        int insertValue = 0;
        int insertIndex = 0;
        long start = System.currentTimeMillis();
        for (int i = 1; i < array.length; i++) {
            insertValue = array[i];
            insertIndex = i - 1;
            // 给insertValue找到插入的位置
            // 1: insertIndex >= 0,保证在找位置时，数组角标不越界
            // 2: insertValue < array[insertIndex] 说明待插入的数还没有找到插入的位置
            // 3: 需要将array[insertIndex]后移
            while (insertIndex >= 0 && insertValue < array[insertIndex]) {
                array[insertIndex + 1] = array[insertIndex];
                insertIndex--;
            }
            if (insertIndex + 1 != i) {
                array[insertIndex + 1] = insertValue;
            }
        }
        long end = System.currentTimeMillis();
        System.out.println("排序共花费了：" + (end - start) + "毫秒");
//        System.out.println(Arrays.toString(array));
    }
}
```

## 1.7 希尔排序

简单插入排序存在的问题:

我们看简单的插入排序可能存在的问题. 

数组 arr = {2,3,4,5,6,1}

 这时需要插入的数 1(最小),

 这样的过程是：

{2,3,4,5,6,6}

{2,3,4,5,5,6}

{2,3,4,4,5,6}

{2,3,3,4,5,6}

{2,2,3,4,5,6}

{1,2,3,4,5,6}

结论: 当需要插入的数是较小的数时，后移的次数明显增多，对效率有影响.

希尔排序法介绍: 希尔排序是希尔（Donald Shell）于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序

基本思想：希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止

示意图：

![1639576107957](D:\360MoveData\Users\25502\Desktop\数据结构\assets\1639576107957.png)

![1639576124421](D:\360MoveData\Users\25502\Desktop\数据结构\assets\1639576124421.png)

注意：希尔排序可以分为两种

希尔排序时， 对有序序列在插入时采用交换法, 并测试排序速度。

希尔排序时， 对有序序列在插入时采用移动法, 并测试排序速度。

代码展示：

```java
package com.paofu.data_structure.day03.sort;

import java.util.Arrays;

/**
 * @author zhangqiang
 * @version 1.0
 * @date 2021/12/15 19:19
 * 希尔排序(缩小增量排序)
 */
public class ShellSort {

    public static void main(String[] args) {
        int[] array = {8, 9, 1, 7, 2, 3, 5, 4, 6, 0};
        int[] testArray = new int[80000];
        for (int i = 0; i < 80000; i++) {
            testArray[i] = (int) (Math.random() * 80000);
        }
        int[] testArray1 = new int[80000];
        for (int i = 0; i < 80000; i++) {
            testArray1[i] = (int) (Math.random() * 80000);
        }
        shellSortExchange(testArray);
        shellSortMove(testArray1);
    }

    /**
     * 希尔排序(交换法)
     * @param array  数组
     */
    public static void shellSortExchange(int[] array) {
        int temp = 0;
        int count = 0;
        long start = System.currentTimeMillis();
        for (int gap = array.length / 2; gap > 0; gap /= 2) {
            // 希尔排序的第gap轮排序
            // 将10个数据分为了gap组
            for (int i = gap; i < array.length; i++) {
                for (int j = i - gap; j >= 0; j -= gap) {
                    // 如果当前元素大于加上步长后的那个元素，则交换
                    if (array[j] > array[j + gap]) {
                        temp = array[j];
                        array[j] = array[j + gap];
                        array[j + gap] = temp;
                    }
                }
            }
//            System.out.println("希尔排序第" + (++count) + "轮排序后为：" + Arrays.toString(array));
        }
        long end = System.currentTimeMillis();
        System.out.println("排序共花费了：" + (end - start) + "毫秒");
    }

    /**
     * 因为传入的数组长度为10，根据10/2=5 5/2=2 2/2=1 1/2 = 0 !> 0 所以此次共分为三步
     * @param array  数组
     */
    public static void shellSortByStep(int[] array) {
        int temp = 0;
        // 希尔排序的第一轮排序
        // 第一轮排序，将10个数据分为了10 / 2 = 5组
        for (int i = 5; i < array.length; i++) {
            for (int j = i - 5; j >= 0; j -= 5) {
                // 如果当前元素大于加上步长后的那个元素，则交换
                if (array[j] > array[j + 5]) {
                    temp = array[j];
                    array[j] = array[j + 5];
                    array[j + 5] = temp;
                }
            }
        }
        System.out.println("希尔排序第一轮排序后为：" + Arrays.toString(array));

        // 希尔排序的第二轮排序
        // 第二轮排序，将10个数据分为了10 / 2 / 2 = 2组
        for (int i = 2; i < array.length; i++) {
            for (int j = i - 2; j >= 0; j -= 2) {
                // 如果当前元素大于加上步长后的那个元素，则交换
                if (array[j] > array[j + 2]) {
                    temp = array[j];
                    array[j] = array[j + 2];
                    array[j + 2] = temp;
                }
            }
        }
        System.out.println("希尔排序第二轮排序后为：" + Arrays.toString(array));

        // 希尔排序的第三轮排序
        // 第三轮排序，将10个数据分为了10 / 2 / 2 / 2 = 1组
        for (int i = 1; i < array.length; i++) {
            for (int j = i - 1; j >= 0; j -= 1) {
                // 如果当前元素大于加上步长后的那个元素，则交换
                if (array[j] > array[j + 1]) {
                    temp = array[j];
                    array[j] = array[j + 1];
                    array[j + 1] = temp;
                }
            }
        }
        System.out.println("希尔排序第二轮排序后为：" + Arrays.toString(array));
    }

    /**
     * 希尔排序(移位法)
     * @param array  数组
     */
    public static void shellSortMove(int[] array) {
        int temp = 0;
        int count = 0;
        long start = System.currentTimeMillis();
        for (int gap = array.length / 2; gap > 0; gap /= 2) {
            // 希尔排序的第gap轮排序
            // 将10个数据分为了gap组
            for (int i = gap; i < array.length; i++) {
                int j = i;
                temp = array[j];
                if (array[j] < array[j - gap]) {
                    while (j - gap >= 0 && temp < array[j - gap]) {
                        // 移动
                        array[j] = array[j - gap];
                        j -= gap;
                    }
                    array[j] = temp;
                }
            }
//            System.out.println("希尔排序第" + (++count) + "轮排序后为：" + Arrays.toString(array));
        }
        long end = System.currentTimeMillis();
        System.out.println("排序共花费了：" + (end - start) + "毫秒");
    }
}
```

## 1.8 快速排序

介绍：快速排序（Quicksort）是对冒泡排序的一种改进。基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列

示意图：![1639576210524](D:\360MoveData\Users\25502\Desktop\数据结构\assets\1639576210524.png)

代码展示：

```java
package com.paofu.data_structure.day03.sort;

import java.util.Arrays;

/**
 * @author zhangqiang
 * @version 1.0
 * @date 2021/12/15 20:09
 * 快速排序
 */
public class QuickSort {

    public static void main(String[] args) {
        int[] array = {-9, 78, 0, 23, -567, 70};
        int[] testArray = new int[80000000];
        for (int i = 0; i < 80000000; i++) {
            testArray[i] = (int) (Math.random() * 80000000);
        }
        long start = System.currentTimeMillis();
        quickSort(testArray, 0, array.length - 1);
        long end = System.currentTimeMillis();
        System.out.println("排序共花费了：" + (end - start) + "毫秒");
    }

    public static void quickSort(int[] array, int left, int right) {
        // 左下标
        int l = left;
        // 右下标
        int r = right;
        // pivot代表中轴值
        int pivot = array[(left + right) / 2];
        int temp = 0;
        // while的目的是让比pivot值小的放到左边，比pivot值大的放到右边
        while (l < r) {
            // 在pivot的左边一直找，找到大于等于pivot的值，才退出
            while (array[l] < pivot) {
                l += 1;
            }
            // 在pivot的右边一直找，找到小于等于pivot的值，才退出
            while (array[r] > pivot) {
                r -= 1;
            }
            // 如果l >= r说明pivot的左边全部是小于等于pivot的值，右边全是大于等于pivot的值
            if (l >= r) {
                break;
            }
            // 交换
            temp = array[l];
            array[l] = array[r];
            array[r] = temp;

            // 如果交换完后，发现arr[l] == pivot，前移
            if (array[l] == pivot) {
                r -= 1;
            }
            // 如果交换完后，发现arr[r] == pivot，前移
            if (array[r] == pivot) {
                l += 1;
            }
        }
        // 如若l == r,必须l++, r--，否则出现栈溢出
        if (l == r) {
            l += 1;
            r -= 1;
        }
        // 向左递归
        if (left < r) {
            quickSort(array, left, r);
        }
        // 向右递归
        if (right > l) {
            quickSort(array, l, right);
        }


    }
}
```

## 1.9 归并排序

介绍：

归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之)。

示意图1：

![1639576278853](D:\360MoveData\Users\25502\Desktop\数据结构\assets\1639576278853.png)

说明:可以看到这种结构很像一棵完全二叉树，本文的归并排序我们采用递归去实现（也可采用迭代的方式去实现）。分阶段可以理解为就是递归拆分子序列的过程。

示意图2--合并相邻有序子序列：

再来看看治阶段，我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将[4,5,7,8]和[1,2,3,6]两个已经有序的子序列，合并为最终序列[1,2,3,4,5,6,7,8]，来看下实现步骤

![1639576330382](D:\360MoveData\Users\25502\Desktop\数据结构\assets\1639576330382.png)

![1639576334234](D:\360MoveData\Users\25502\Desktop\数据结构\assets\1639576334234.png)

代码展示：

```java
package com.paofu.data_structure.day03.sort;

import java.util.Arrays;

/**
 * @author zhangqiang
 * @version 1.0
 * @date 2021/12/15 21:03
 * 归并排序
 */
public class MergeSort {

    public static void main(String[] args) {
        int[] array = {8, 4, 5, 7, 1, 3, 6, 2};
        int[] temp = new int[array.length];
        mergeSort(array, 0, array.length - 1, temp);
        System.out.println(Arrays.toString(array));
    }

    public static void mergeSort(int[] array, int left, int right, int[] temp) {
        if (left < right) {
            int mid = (left + right) / 2;
            // 向左递归进行分解
            mergeSort(array, left, mid, temp);
            // 向右递归分解
            mergeSort(array, mid + 1, right, temp);
            // 合并
            merge(array, left, mid, right, temp);
        }
    }

    /**
     * 归并排序的合并方法
     * @param array 待排序数组
     * @param left  左边有序序列的初始索引
     * @param mid 中间索引
     * @param right 右边有序序列的初始索引
     * @param temp 中转数组
     */
    public static void merge(int[] array, int left, int mid, int right, int[] temp) {
        // 初始化i，左边有序序列的初始索引
        int i = left;
        // 初始化j，右边有序序列的初始索引
        int j = mid + 1;
        // 中转数组的存放位置当前索引
        int t = 0;
        // 1:先把左右两边的数据按规则填充到中转数组temp。知道左右两边有序序列有一方处理完毕
        while (i <= mid && j <= right) {
            // 如果左边有序序列的当前元素小于等于右边有序序列的当前元素，把左边序列当前元素拷贝到temp中转数组
            if (array[i] <= array[j]) {
                temp[t] = array[i];
                t++;
                i++;
            } else {
                temp[t] = array[j];
                t++;
                j++;
            }
        }

        // 2:把有剩余数据的一边依次填充到temp中
        // 说明左边的序列有剩余元素
        while (i <= mid) {
            temp[t] = array[i];
            t++;
            i++;
        }
        // 说明右边的序列有剩余元素
        while (j <= right) {
            temp[t] = array[j];
            t++;
            j++;
        }

        // 3:将temp数组元素拷贝到array
        // 并不是每次都拷贝所有
        t = 0;
        int tempLeft = left;
        while (tempLeft <= right) {
            array[tempLeft] = temp[t];
            t++;
            tempLeft++;
        }

    }
}
```